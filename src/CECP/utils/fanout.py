import gdstk
import numpy as np



def square_spiral(N: int) -> np.array:
    """Creates a square spiral of length N.
    
    Generated by ChatGPT.
    """
    x, y = 0, 0
    dx, dy = 1, 0  # Start moving right
    step = 1
    coords = [(x, y)]
    while len(coords) < N:
        for _ in range(2):  # Repeat for dx, dy pair
            for _ in range(step):
                if len(coords) >= N:
                    return np.array(coords)
                x, y = x + dx, y + dy
                coords.append((x, y))
            dx, dy = -dy, dx  # Rotate direction
        step += 1  # Increase step every full cycle
    return np.array(coords)


def fan_out_design(in_file, out_file, layer_mapping, die_size: float=20_000, fan_out_gap: float=1_000):
    """Flattens the provided GDS design and places the defined layers in a square spiral out from the centre.
    This function can be used to automatically spread a chip design across a mask.
    
    Example usage
    
    in = R"path/to/file.gds"
    out = R"path/to/file_fanout.gds"
    layers = [
        (24, 198), 
        (20, 199), 
        (26, 30, 200),
        (35, 201),
        (34, 202),
        (40, 198, 199, 200, 201, 202),
        (90, ),
    ]
    fan_out_design(in, out, layers)

    Parameters
    ----------
    in_file
        .
    out_file
        .
    layer_mapping
        .
    die_size : float, optional
        Size of individual die. Defaults to 20'000 um.
    fan_out_gap : float, optional
        Gap between each die. Defaults to 1'000 um.
    
    Returns
    -------
    list of str
        Layer text of the square spiral.
    list of (float, float)
        Cooindates of the square spiral.
    """
    # load input library
    source_library = gdstk.read_gds(in_file)
    top = source_library.top_level()[0]
    flat = top.flatten()
    
    # initialise output library
    fan_out_library = gdstk.Library()
    top_fan_out = fan_out_library.new_cell("TOP")
    
    # spiral out
    names = []
    coords = square_spiral(len(layer_mapping)+1)
    die_coords = coords * (die_size + fan_out_gap)
    for i, layers in enumerate(layer_mapping):
        polygons = [polygon for polygon in flat.polygons if polygon.layer in layers]
        # could also add polarity of layer I guess
        name = f'L{str(layers)[1:-1]}'
        cell = gdstk.Cell(name)
        _ = cell.add(*polygons)
        names.append(name)
        _ = fan_out_library.add(cell)
        _ = top_fan_out.add(gdstk.Reference(cell, die_coords[i]))
    
    _ = fan_out_library.write_gds(out_file)
    return names, coords

# if "__name__" == "__main__":
#     # not implemented yet
#     import argparse
#     parser = argparse.ArgumentParser()
#     parser.add_argument("in_file", help="path to the gds file which should be deconstructed")
#     parser.add_argument("out_file", help="path to save the resulting gds to")
#     parser.add_argument("layers")
#     args = parser.parse_args()
#     fan_out_design(args.in_file, args.out_file, args.layers)


