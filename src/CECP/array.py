# helper functions to make arrays of things, particularly by sweeping some parameters
# should also give exclusion functionality

import gdstk
import itertools
import numpy as np

from .base import Feature, FabString
from .shapes import rectangle
from .merge import get_children
from .components import make_label



def has_overlap(
        generating_class: Feature, 
        origin: tuple[float, float],
        exclusions: list[gdstk.Polygon],
        ) -> bool:
    """Checks if the device a generated by the supplied Feature subclass overlaps with a specified exclusion.
    
    Parameters
    ----------
    generating_class : NDL.base.Feature
        Cell to check if overlaps with an excluded polygon.
    origin : (float, float)
        Reference origin at which to place device.
    exclusions : list of gdstk.Polygon
        Polygons to check for collision with.
    
    Returns
    -------
    bool
    """
    if len(gdstk.boolean(rectangle(generating_class.size[0], generating_class.size[1], origin=origin), exclusions, "and")) > 0:
        return True
    return False


def place_device(
        generator: Feature,
        device: gdstk.Cell,
        origin: tuple[float, float]=(0, 0),
        count: int=0,
        label: dict = {
            "schema": "D-{x:03d}",
            "size": 40,
            "vertical": False,
            "rotation": 0,
        },
        label_position: tuple[float, float]=(0, 0)
    ) -> gdstk.Reference:
    """Create a reference to a device cell at the specified position, 
    optionally with a label.

    Parameters
    ----------
    generator : Feature
        The feature from which the device stems, used to get the layer_map and 
        bounds for the label.
    device : gdstk.Cell
        The cell to reference.
    origin : (float, float), optional
        Where to centre the cell reference. Defaults to (0, 0).
    count : int, optional
        Which number to place in the label. Defaults to 0.
    label : dict, optional
        Parameters to apply to the label.
    label_position : (float, float), optional
        Where to place the label for the cell. This should normally be defined 
        in the components dict from the build call. Defaults to (0, 0.).
    
    Returns
    -------
    gdstk.Reference
    """
    if not label["schema"]:
        return gdstk.Reference(device, origin)
    labelled_cell = gdstk.Cell(FabString(label["schema"].replace("-", "_").format(x=count)))
    labelled_cell.add(gdstk.Reference(device, (0, 0)))
    label_polygons = make_label(
        label["schema"].format(x=count), 
        size=label["size"], 
        origin=label_position,
        rotation=label["rotation"],
        vertical=label["vertical"], 
    )
    labelled_cell.add(
        *generator.layer_map["labels"].apply(
            label_polygons, 
            generator.bounds
            )
        )
    return gdstk.Reference(labelled_cell, origin)


def make_rc_array(
        generating_class: Feature,
        parameters: list,
        label_schema: str="D-{x:03d}",
        label_fmt: dict = {
            "size": 40,
            "vertical": False,
            "rotation": 0,
        },
        count_0: int=1,
        axis: int=0,
        repeat_perp: int=1,
        repeat_para: int=1,
        exclusions: list[gdstk.Polygon]=[],
        ) -> tuple[gdstk.Cell, list[gdstk.Cell]]:
    """Make an array with parameters swept across rows and columns.
    
    Template for standard device arrays.
    
    Parameters
    ----------
    generating_class : NDL.base.Feature
        The function used to generate the device to place. When called with a 
        parameter should return a cell.
    parameters : list
        The parameters to supply to the generating function.
    label_schema: str, optional
        The text format the labels should take. Should be a valid str.format 
        template. Defaults to "D-{x:03d}" which evaluates to e.g. "D-056". If
        is empty string, no label is added.
    label_fmt : dict, optional
        Format parameters for the label, such as rotation and size.
    count_0 : int, optional
        Initial value to label devices from. Defaults to 1.
    axis : int, optional
        Along which axis generate the devices. Defaults to 0, which is the 
        rows.
    repeat_perp : int, optional
        How many times to repeat a device perpendicular to the axis. This 
        repetition extends perpendicular to axis. Defaults to 1.
    repeat_para : int, optional
        How many times to repeat a device parallel to the axis. This 
        repetition extends perpendicular to axis. Defaults to 1.
    exclusions : list of gdstk.Polygon
        Areas where a device should not be placed. No device is placed if it 
        would touch any of these areas. Defaults to an empty list.
    
    Returns
    -------
    gdstk.Cell
        The cell representing the array.
    list of gdstk.Cell
        All cells under the array cell, including the array cell itself.
    """
    array = gdstk.Cell(FabString(f"Array_{generating_class.name}"))
    count = count_0
    if axis == 0:
        size = (
            repeat_para*len(parameters)*generating_class.size[0],
            repeat_perp*generating_class.size[1]
        )
    else:
        size = (
            repeat_perp*generating_class.size[0],
            repeat_para*len(parameters)*generating_class.size[1]
        )
    for i,p in enumerate(parameters):
        device, components = generating_class.build(p)
        for k in range(repeat_para):
            for j in range(repeat_perp):
                if axis == 0:
                    origin = ((i*repeat_para+k)*generating_class.size[0], j*generating_class.size[1])
                elif axis == 1:
                    origin = (j*generating_class.size[0], (i*repeat_para+k)*generating_class.size[1])                    
                else:
                    raise ValueError("'axis' is not 0 or 1.")
                origin = (origin[0] - size[0]/2 + generating_class.size[0]/2, origin[1] - size[1]/2 + generating_class.size[1]/2)
                if has_overlap(generating_class, origin, exclusions):
                    continue
                ref = place_device(generating_class, device, origin, count, 
                    label_fmt | {"schema": label_schema},
                    components["label_pos"])
                array.add(ref)
                count += 1
    devices = get_children(array)
    return array, devices


def make_multiparam_array(
        generating_class: Feature,
        parameters: list[list],
        label_schema: str="D-{x:03d}",
        label_fmt: dict = {
            "size": 40,
            "vertical": False,
            "rotation": 0,
        },
        count_0: int=1,
        axis: int=0,
        repeat_perp: int=1,
        repeat_para: int=1,
        meta_rc: int=1,
        exclusions: list[gdstk.Polygon]=[],
        exclusion_type: str="skip",
        ) -> tuple[gdstk.Cell, list[gdstk.Cell]]:
    """Make an array with multiple parameters swept across rows and columns.
        
    Parameters
    ----------
    generating_class : NDL.base.Feature
        The function used to generate the device to place. When called with a 
        parameter should return a cell.
    parameters : list of lists
        The parameters to supply to the generating functions.
    label_schema: str, optional
        The format the labels should take. Should be a valid str.format 
        template. Defaults to "D-{x:03d}" which evaluates to e.g. "D-056". If
        is empty string, no label is added.
    count_0 : int, optional
        Initial value to label devices from. Defaults to 1.
    axis : int, optional
        Along which axis generate the devices. Defaults to 1, which is the 
        rows.
    repeat_perp : int, optional
        How many times to repeat a device perpendicular to the axis. This 
        repetition extends perpendicular to axis. Defaults to 1.
    repeat_para : int, optional
        How many times to repeat a device parallel to the axis. This 
        repetition extends perpendicular to axis. Defaults to 1.
    meta_rc : int=1, optional
        How many rows/columns the data should be split across.
        e.g. with axis=0, repeat=2, meta_rc=2, the array would look like this:
        [1, 1, 4, 4]
        [2, 2, 5, 5]
        [3, 3, 6, 6]
        Defaults to 1.
    exclusions : list of gdstk.Polygon1, optional
        Areas where a device should not be placed. No device is placed if it 
        would touch any of these areas. Defaults to an empty list.
    exclusion_type : str, optional
        Whether a device inside an exclusion should be skipped or place in the 
        next position. Defaults to "skip" which means that device is voided.
    
    Returns
    -------
    gdstk.Cell
        The cell representing the array.
    list of gdstk.Cell
        All cells under the array cell, including the array cell itself.
    """
    combinations = list(itertools.product(*parameters))
    array = gdstk.Cell(FabString(f"Array_{generating_class.name}"))
    coord_sequence = []
    if axis == 0:
        col_per_row = len(combinations)*repeat_para // meta_rc
        for i in range(len(combinations)*repeat_para):
            y_offset = generating_class.size[1] * repeat_perp * (i // col_per_row)
            x_offset = generating_class.size[0] * (i % col_per_row)
            for r in range(repeat_perp):
                coord_sequence.append(
                    (x_offset, 
                    y_offset + generating_class.size[1] * r)
                )
    elif axis == 1:
        row_per_col = len(combinations)*repeat_para // meta_rc
        for i in range(len(combinations)*repeat_para):
            x_offset = generating_class.size[0] * repeat_perp * (i // row_per_col)
            y_offset = generating_class.size[1] * (i % row_per_col)
            for r in range(repeat_perp):
                coord_sequence.append(
                    (x_offset + generating_class.size[0] * r, 
                     y_offset)
                )
    else:
        raise ValueError("'axis' is not 0 or 1.")
    idx = 0
    count = count_0
    for parameter_set in combinations:
        device, components = generating_class.build(*parameter_set)
        for r in range(repeat_perp*repeat_para):
            if has_overlap(generating_class, coord_sequence[idx], exclusions):
                if exclusion_type != "skip":
                    r -= 1    
                idx += 1
                continue
            # centre array around 0
            origin = (
                coord_sequence[idx][0] - coord_sequence[-1][0]/2,
                coord_sequence[idx][1]- coord_sequence[-1][1]/2
            )
            ref = place_device(generating_class, device, origin, count, 
                    label_fmt | {"schema": label_schema},
                    components["label_pos"]
                    )
            array.add(ref)
            idx += 1
            count += 1
    devices = get_children(array)
    return array, devices